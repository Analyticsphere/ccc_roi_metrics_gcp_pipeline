---
title: "ROI Custom QC"
author: "Kelsey Sanchez"
date: "`r Sys.Date()`"
output:
  pdf_document:
      latex_engine: xelatex
      toc: true
---


```{r library, include=FALSE}
library(bigrquery)
library(gmodels)
library(gtsummary)
library(gt)
library(tinytex)
library(tidyverse)
library(dplyr) 
library(sqldf) 
library(lubridate)
library(kableExtra)
library(knitr)
library(kableExtra)

bq_auth()
```


\newpage
# Physical Activity (PA)

```{r BQ, include=FALSE}

project <- "nih-nci-dceg-connect-prod-6d04"



#### Pull data from both versions of Module 2. Some people have data in both versions
## need only version2 data for those people

recr_m2 <- bq_project_query(project, query="SELECT token,Connect_ID, d_821247024, d_914594314,  d_827220437,d_512820379, 
                            d_536735468 , d_517311251  FROM  `nih-nci-dceg-connect-prod-6d04.FlatConnect.participants` WHERE  d_821247024='197316935'")
recr_m2 <- bq_table_download(recr_m2,bigint = "integer64",n_max = Inf, page_size = 10000)
cnames <- names(recr_m2)
# Check that it doesn't match any non-number
numbers_only <- function(x) !grepl("\\D", x)
# to check variables in recr_noinact_wl1
for (i in 1: length(cnames)){
  varname <- cnames[i]
  var<-pull(recr_m2,varname)
  recr_m2[,cnames[i]] <- ifelse(numbers_only(var), as.numeric(as.character(var)), var)
}



### Deal with Mod2 duplicates (took both version 1 and vesion 2, and only select version 2 data)
sql_M2_1 <- bq_project_query(project, query = "SELECT * FROM `nih-nci-dceg-connect-prod-6d04.FlatConnect.module2_v1` WHERE Connect_ID IS NOT NULL")
sql_M2_2 <- bq_project_query(project, query = "SELECT * FROM `nih-nci-dceg-connect-prod-6d04.FlatConnect.module2_v2` WHERE Connect_ID IS NOT NULL")

M2_V1 <- bq_table_download(sql_M2_1, bigint = "integer64")
M2_V2 <- bq_table_download(sql_M2_2, bigint = "integer64")

# Select matching column names
M2_V1_vars <- colnames(M2_V1)
M2_V2_vars <- colnames(M2_V2)
common_vars <- intersect(M2_V1_vars, M2_V2_vars)

# Subset to common columns
M2_V1_common <- M2_V1[, common_vars]
M2_V2_common <- M2_V2[, common_vars]

# Add version indicator
M2_V1_common$version <- 1
M2_V2_common$version <- 2

# Identify columns with mismatched types
mismatched_cols <- names(M2_V1_common)[sapply(names(M2_V1_common), function(col) {
  class(M2_V1_common[[col]]) != class(M2_V2_common[[col]])
})]

# Convert mismatched columns to character for consistency
M2_V1_common <- M2_V1_common %>%
  mutate(across(all_of(mismatched_cols), as.character))
M2_V2_common <- M2_V2_common %>%
  mutate(across(all_of(mismatched_cols), as.character))

# Combine both versions for participants who completed both
M2_common <- bind_rows(M2_V1_common, M2_V2_common) %>%
  arrange(Connect_ID, desc(version))

# For columns unique to each version
V1_only_vars <- setdiff(M2_V1_vars, common_vars)
V2_only_vars <- setdiff(M2_V2_vars, common_vars)

# Subset each version for unique columns and add version indicator
m2_v1_only <- M2_V1[, c("Connect_ID", V1_only_vars)] %>%
  mutate(version = 1)
m2_v2_only <- M2_V2[, c("Connect_ID", V2_only_vars)] %>%
  mutate(version = 2)

# Combine the unique and common data
M2_common_v1 <- left_join(M2_common, m2_v1_only, by = c("Connect_ID", "version"))
M2_combined_v1v2 <- left_join(M2_common_v1, m2_v2_only, by = c("Connect_ID", "version"))

# Filter for complete cases where specific completion criteria are met
M2_complete <- M2_combined_v1v2 %>%
  filter(Connect_ID %in% recr_m2$Connect_ID[recr_m2$d_536735468 == 231311385]) %>%
  arrange(desc(version))

# Remove duplicates, keeping only the most recent version for each Connect_ID
M2_complete_nodup <- M2_complete[!duplicated(M2_complete$Connect_ID),]
table(M2_complete_nodup$version)

M2_complete_nodup$Connect_ID <- as.numeric(M2_complete_nodup$Connect_ID)




#### Pull necessary variables from participants table
parts <- "SELECT Connect_ID, token, d_832139544,
        d_821247024,
        d_747006172,
        d_987563196,
        d_536735468,
        d_686238347_d_446235715,
        d_686238347_d_749055145,
        d_686238347_d_295732360
        FROM `nih-nci-dceg-connect-prod-6d04.FlatConnect.participants`
        WHERE d_821247024 = '197316935'     -- is verified
        AND d_747006172 = '104430631' -- has not withdrawn consent
        AND d_987563196 = '104430631' -- not deceased
        AND d_536735468 ='231311385'  -- has submitted module 2"

parts_table <- bq_project_query(project, parts)
parts_data <- bq_table_download(parts_table, bigint = "integer64",n_max = Inf, page_size = 10000)

parts_data$Connect_ID <- as.numeric(parts_data$Connect_ID)



physical_activity_ROI= left_join(parts_data, M2_complete_nodup, by="Connect_ID")



## Pulling in ROI table
physical_activity <- "SELECT * FROM `nih-nci-dceg-connect-prod-6d04.ROI.physical_activity`"
physical_activity_BQ <- bq_project_query(project, physical_activity)
physical_activity_BQ <- bq_table_download(physical_activity_BQ, bigint = "integer64")

physical_activity_BQ$Connect_ID <- as.numeric(physical_activity_BQ$Connect_ID)

physical_activity_ROI_full = left_join(physical_activity_ROI, physical_activity_BQ, by = "Connect_ID")

```


```{r Addtl_Clms, include=FALSE}


physical_activity_ROI_full <- physical_activity_ROI_full %>%  
  mutate(report_appended = case_when(is.na(d_416831581) ~ "No",
                                    TRUE ~ "Yes"),
        viewed_status = case_when(d_686238347_d_446235715=='469323437' ~ "Viewed",
                                  d_686238347_d_446235715=='702641611' ~ "Unread",
                                  d_686238347_d_446235715=='746038746' ~ "Declined",
                                  TRUE ~ "Null"),
        viewed_date_flag = case_when(is.na(d_686238347_d_749055145) ~ "Null",
                                     TRUE ~ "Populated"),
        declined_date_flag = case_when(is.na(d_686238347_d_295732360) ~ "Null",
                                       TRUE ~ "Populated"),
        ## True Missings: those who skipped the entire exercise section
        ## If they skipped EXEREC1, then they would also never see the follow up questions for : 
        ##  seasons doing exercise, duration of exercise, or frequency of exercise
        true_missing = case_when(if_all(matches("517976064"), ~ is.na(.x) | .x == 0) ~ 1,
                                 TRUE ~ 0)) 

```




### Rule 1: If Module 2 was submitted more than 72 hours ago and the base physical act question (EXEREC1) was answered, then the participant should have data in the ROI BQ table for PA.
```{r Rule 1, echo=FALSE, warning=FALSE, message=FALSE}

#416831581 is the date ROI PA table appended. This means that a PA report was generated for this person. There is a lag time for PA report generation

rule1 <- physical_activity_ROI_full %>% 
  filter(as.numeric(difftime(Sys.Date(), as.POSIXct(ymd_hms(d_832139544)),units="hours")) >72 & true_missing == 0)
rule1 <- rule1 %>% filter(is.na(d_416831581)) %>% select(Connect_ID, d_416831581, d_832139544)
colnames(rule1) <- c("Connect_ID", "ROIPhy_PATableAppendTm_v1r0", "SrvMRE_TmComplete_v1r0")
 
knitr::kable(rule1)
```

### Rule 2: If the base physical act question (EXEREC1) was unanswered, then report appended flag=null and report viewed status=null (should not receive a report).
```{r Rule 2, echo=FALSE, warning=FALSE, message=FALSE}

rule2 <- physical_activity_ROI_full %>% 
  filter(true_missing == 1 & (report_appended == "Yes" | viewed_status != "Null")) %>% 
  select(Connect_ID, report_appended, viewed_status)
 
colnames(rule2) <- c("Connect_ID", "Report Appended Flag", "Report Viewed Status Flag")
knitr::kable(rule2)
```

### Rule 3: If there is a date in ROI PA BQ table appended flag then the Report Viewed Status should not be null.
```{r Rule 3, echo=FALSE, warning=FALSE, message=FALSE}
  
 rule3 <- physical_activity_ROI_full %>% 
    filter(report_appended == "Yes" & viewed_status == "Null") %>%  select(Connect_ID, report_appended, viewed_status)

colnames(rule3) <- c("Connect_ID", "Report Appended Date Flag", "Report Viewed Status Flag")
knitr::kable(rule3)

```

### Rule 4: If report date/time for report viewed is populated then report viewed status flag must not equal null or unread.
```{r Rule 4, echo=FALSE, warning=FALSE, message=FALSE}
rule4 <- physical_activity_ROI_full %>% 
  filter(viewed_date_flag == "Populated" & (viewed_status == "Unread" | viewed_status == "Null")) %>% select(Connect_ID, viewed_date_flag, viewed_status)

  colnames(rule4) <- c("Connect_ID", "Report Viewed Date Flag", "Report Viewed Status Flag")
  knitr::kable(rule4)

```

### Rule 5: If report date/time for report declined is populated then report viewed status flag must not equal null or unread.
```{r Rule 5, echo=FALSE, warning=FALSE, message=FALSE}
rule5 <- physical_activity_ROI_full %>% 
  filter(declined_date_flag == "Populated" & (viewed_status == "Unread" | viewed_status == "Null")) %>% select(Connect_ID, declined_date_flag, viewed_status)

  colnames(rule5) <- c("Connect_ID", "Report Declined Date Flag", "Report Viewed Status Flag")
  knitr::kable(rule5)
```

### Rule 6: If report viewed status flag is unread, then date/time for report viewed and date/time for report declined must both be null.
```{r Rule 6, echo=FALSE, warning=FALSE, message=FALSE}
rule6 <- physical_activity_ROI_full %>%
  filter(viewed_status == "Unread" & ((viewed_date_flag != "Null") | (declined_date_flag != "Null"))) %>%  
  select(Connect_ID, viewed_status, viewed_date_flag, declined_date_flag)

colnames(rule6) <- c("Connect_ID", "Report Viewed Status Flag", "Report Viewed Date Flag", "Report Declined Date Flag")
knitr::kable(rule6)

```


\newpage
# Healthy Eating Index (HEI)
